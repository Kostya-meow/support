from __future__ import annotations

from datetime import datetime
from typing import Iterable, Optional

from sqlalchemy import delete, select, func, and_
from sqlalchemy.ext.asyncio import AsyncSession

from app import models


# ========== TICKETS ==========

async def get_open_ticket_by_chat_id(
    session: AsyncSession,
    telegram_chat_id: int,
) -> Optional[models.Ticket]:
    """ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚ÑƒÑ Ğ·Ğ°ÑĞ²ĞºÑƒ Ğ´Ğ»Ñ Ğ´Ğ°Ğ½Ğ½Ğ¾Ğ³Ğ¾ Ñ‡Ğ°Ñ‚Ğ°."""
    result = await session.execute(
        select(models.Ticket).where(
            and_(
                models.Ticket.telegram_chat_id == telegram_chat_id,
                models.Ticket.status.in_([models.TicketStatus.OPEN, models.TicketStatus.IN_PROGRESS])
            )
        )
    )
    return result.scalar_one_or_none()


async def create_ticket(
    session: AsyncSession,
    telegram_chat_id: int,
    title: Optional[str] = None,
) -> models.Ticket:
    """Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ğ½Ğ¾Ğ²ÑƒÑ Ğ·Ğ°ÑĞ²ĞºÑƒ."""
    ticket = models.Ticket(
        telegram_chat_id=telegram_chat_id,
        title="Ğ’Ñ€ĞµĞ¼ĞµĞ½Ğ½Ğ°Ñ Ğ·Ğ°ÑĞ²ĞºĞ°",  # Ğ’Ñ€ĞµĞ¼ĞµĞ½Ğ½Ñ‹Ğ¹ Ğ·Ğ°Ğ³Ğ¾Ğ»Ğ¾Ğ²Ğ¾Ğº
        status=models.TicketStatus.OPEN
    )
    session.add(ticket)
    await session.commit()
    await session.refresh(ticket)
    
    # ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ Ğ·Ğ°Ğ³Ğ¾Ğ»Ğ¾Ğ²Ğ¾Ğº Ñ Ğ½Ğ¾Ğ¼ĞµÑ€Ğ¾Ğ¼ Ğ·Ğ°ÑĞ²ĞºĞ¸
    if title:
        ticket.title = f"Ğ—Ğ°ÑĞ²ĞºĞ° #{ticket.id} - {title}"
    else:
        ticket.title = f"Ğ—Ğ°ÑĞ²ĞºĞ° #{ticket.id} - ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ {telegram_chat_id}"
    await session.commit()
    
    return ticket


async def list_tickets(
    session: AsyncSession,
    *,
    status: Optional[models.TicketStatus] = None,
    archived: bool = False,
) -> list[models.Ticket]:
    """ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ ÑĞ¿Ğ¸ÑĞ¾Ğº Ğ·Ğ°ÑĞ²Ğ¾Ğº."""
    stmt = select(models.Ticket).order_by(models.Ticket.updated_at.desc())
    
    if status:
        stmt = stmt.where(models.Ticket.status == status)
    elif archived:
        # ĞÑ€Ñ…Ğ¸Ğ² - Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚Ñ‹Ğµ Ğ¸ Ğ°Ñ€Ñ…Ğ¸Ğ²Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ·Ğ°ÑĞ²ĞºĞ¸
        stmt = stmt.where(models.Ticket.status.in_([models.TicketStatus.CLOSED, models.TicketStatus.ARCHIVED]))
    else:
        # ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğµ Ğ·Ğ°ÑĞ²ĞºĞ¸ - Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚Ñ‹Ğµ Ğ¸ Ğ² Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğµ
        stmt = stmt.where(models.Ticket.status.in_([models.TicketStatus.OPEN, models.TicketStatus.IN_PROGRESS]))
    
    result = await session.execute(stmt)
    return result.scalars().all()


async def get_ticket_by_id(
    session: AsyncSession,
    ticket_id: int,
) -> Optional[models.Ticket]:
    """ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ·Ğ°ÑĞ²ĞºÑƒ Ğ¿Ğ¾ ID."""
    return await session.get(models.Ticket, ticket_id)


async def get_ticket_with_messages(
    session: AsyncSession,
    ticket_id: int,
) -> Optional[tuple[models.Ticket, list[models.Message]]]:
    """ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ·Ğ°ÑĞ²ĞºÑƒ Ñ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸ÑĞ¼Ğ¸ Ğ¿Ğ¾ ID."""
    # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ñ‚Ğ¸ĞºĞµÑ‚
    result = await session.execute(
        select(models.Ticket).where(models.Ticket.id == ticket_id)
    )
    ticket = result.scalar_one_or_none()
    
    if ticket is None:
        return None
    
    # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ
    messages_result = await session.execute(
        select(models.Message)
        .where(models.Message.ticket_id == ticket_id)
        .order_by(models.Message.created_at)
    )
    messages = messages_result.scalars().all()
    
    return ticket, list(messages)


async def update_ticket_status(
    session: AsyncSession,
    ticket_id: int,
    status: models.TicketStatus,
) -> Optional[models.Ticket]:
    """ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ ÑÑ‚Ğ°Ñ‚ÑƒÑ Ğ·Ğ°ÑĞ²ĞºĞ¸."""
    ticket = await session.get(models.Ticket, ticket_id)
    if ticket is None:
        return None
    
    ticket.status = status
    ticket.updated_at = datetime.utcnow()
    
    if status == models.TicketStatus.CLOSED:
        ticket.closed_at = datetime.utcnow()
    elif status == models.TicketStatus.ARCHIVED:
        if not ticket.closed_at:
            ticket.closed_at = datetime.utcnow()
    
    await session.commit()
    await session.refresh(ticket)
    return ticket


async def update_ticket_summary(
    session: AsyncSession,
    ticket_id: int,
    summary: str,
) -> Optional[models.Ticket]:
    """ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ ĞºÑ€Ğ°Ñ‚ĞºĞ¾Ğµ Ğ¾Ğ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ (summary) Ğ·Ğ°ÑĞ²ĞºĞ¸."""
    ticket = await session.get(models.Ticket, ticket_id)
    if ticket is None:
        return None
    
    ticket.summary = summary
    ticket.updated_at = datetime.utcnow()
    
    await session.commit()
    await session.refresh(ticket)
    return ticket


async def set_first_response_time(
    session: AsyncSession,
    ticket_id: int,
) -> Optional[models.Ticket]:
    """Ğ—Ğ°Ğ¿Ğ¸ÑĞ°Ñ‚ÑŒ Ğ²Ñ€ĞµĞ¼Ñ Ğ¿ĞµÑ€Ğ²Ğ¾Ğ³Ğ¾ Ğ¾Ñ‚Ğ²ĞµÑ‚Ğ° Ğ¾Ğ¿ĞµÑ€Ğ°Ñ‚Ğ¾Ñ€Ğ° (ĞµÑĞ»Ğ¸ ĞµÑ‰Ğµ Ğ½Ğµ Ğ·Ğ°Ğ¿Ğ¸ÑĞ°Ğ½Ğ¾)."""
    ticket = await session.get(models.Ticket, ticket_id)
    if ticket is None or ticket.first_response_at is not None:
        return None
    
    ticket.first_response_at = datetime.utcnow()
    ticket.updated_at = datetime.utcnow()
    
    await session.commit()
    await session.refresh(ticket)
    return ticket


# ========== MESSAGES ==========

async def add_message(
    session: AsyncSession,
    ticket_id: int,
    sender: str,
    text: str,
    telegram_message_id: Optional[int] = None,
    is_system: bool = False,
    created_at: Optional[datetime] = None,
) -> models.Message:
    """Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ğ² Ğ·Ğ°ÑĞ²ĞºÑƒ."""
    message = models.Message(
        ticket_id=ticket_id,
        sender=sender,
        text=text,
        telegram_message_id=telegram_message_id,
        is_system=is_system,
    )
    if created_at:
        message.created_at = created_at
    session.add(message)
    await session.commit()
    # ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ Ğ²Ñ€ĞµĞ¼Ñ Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½ĞµĞ³Ğ¾ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ñ Ğ·Ğ°ÑĞ²ĞºĞ¸
    ticket = await session.get(models.Ticket, ticket_id)
    if ticket:
        ticket.updated_at = datetime.utcnow()
        await session.commit()
    
    await session.commit()
    await session.refresh(message)
    return message


async def list_messages_for_ticket(
    session: AsyncSession,
    ticket_id: int,
    include_system: bool = True,
) -> list[models.Message]:
    """ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ²ÑĞµ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ Ğ·Ğ°ÑĞ²ĞºĞ¸."""
    stmt = select(models.Message).where(models.Message.ticket_id == ticket_id)
    
    if not include_system:
        stmt = stmt.where(models.Message.is_system == False)
    
    stmt = stmt.order_by(models.Message.created_at)
    result = await session.execute(stmt)
    return result.scalars().all()


# ========== KNOWLEDGE ==========

async def replace_knowledge_entries(
    session: AsyncSession,
    entries: Iterable[tuple[str, str, bytes]],
) -> None:
    """Ğ—Ğ°Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ğ²ÑĞµ Ğ·Ğ°Ğ¿Ğ¸ÑĞ¸ Ğ² Ğ±Ğ°Ğ·Ğµ Ğ·Ğ½Ğ°Ğ½Ğ¸Ğ¹."""
    await session.execute(delete(models.KnowledgeEntry))
    session.add_all(
        [
            models.KnowledgeEntry(question=question, answer=answer, embedding=embedding)
            for question, answer, embedding in entries
        ]
    )
    await session.commit()


async def load_knowledge_entries(session: AsyncSession) -> list[models.KnowledgeEntry]:
    """Ğ—Ğ°Ğ³Ñ€ÑƒĞ·Ğ¸Ñ‚ÑŒ Ğ²ÑĞµ Ğ·Ğ°Ğ¿Ğ¸ÑĞ¸ Ğ±Ğ°Ğ·Ñ‹ Ğ·Ğ½Ğ°Ğ½Ğ¸Ğ¹."""
    result = await session.execute(select(models.KnowledgeEntry).order_by(models.KnowledgeEntry.id))
    return result.scalars().all()


async def count_knowledge_entries(session: AsyncSession) -> int:
    """ĞŸĞ¾Ğ´ÑÑ‡Ğ¸Ñ‚Ğ°Ñ‚ÑŒ ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ·Ğ°Ğ¿Ğ¸ÑĞµĞ¹ Ğ² Ğ±Ğ°Ğ·Ğµ Ğ·Ğ½Ğ°Ğ½Ğ¸Ğ¹."""
    result = await session.execute(select(func.count()).select_from(models.KnowledgeEntry))
    count = result.scalar_one()
    return int(count or 0)


# ========== DASHBOARD STATISTICS ==========

async def get_tickets_stats(session: AsyncSession) -> dict:
    """ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºÑƒ Ğ¿Ğ¾ Ñ‚Ğ¸ĞºĞµÑ‚Ğ°Ğ¼ Ğ´Ğ»Ñ Ğ´Ğ°ÑˆĞ±Ğ¾Ñ€Ğ´Ğ°."""
    # ĞŸĞ¾Ğ´ÑÑ‡ĞµÑ‚ Ñ‚Ğ¸ĞºĞµÑ‚Ğ¾Ğ² Ğ¿Ğ¾ ÑÑ‚Ğ°Ñ‚ÑƒÑĞ°Ğ¼
    status_stats = {}
    for status in [models.TicketStatus.OPEN, models.TicketStatus.IN_PROGRESS, models.TicketStatus.CLOSED, models.TicketStatus.ARCHIVED]:
        result = await session.execute(
            select(func.count()).select_from(models.Ticket).where(models.Ticket.status == status)
        )
        status_stats[status.value] = result.scalar_one() or 0
    
    # ĞĞ±Ñ‰ĞµĞµ ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ñ‚Ğ¸ĞºĞµÑ‚Ğ¾Ğ²
    total_result = await session.execute(select(func.count()).select_from(models.Ticket))
    total_tickets = total_result.scalar_one() or 0
    
    # Ğ¢Ğ¸ĞºĞµÑ‚Ñ‹ Ğ·Ğ° Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½Ğ¸Ğµ 7 Ğ´Ğ½ĞµĞ¹
    from datetime import datetime, timedelta
    week_ago = datetime.utcnow() - timedelta(days=7)
    week_result = await session.execute(
        select(func.count()).select_from(models.Ticket).where(models.Ticket.created_at >= week_ago)
    )
    tickets_this_week = week_result.scalar_one() or 0
    
    # Ğ¢Ğ¸ĞºĞµÑ‚Ñ‹ Ğ·Ğ° ÑĞµĞ³Ğ¾Ğ´Ğ½Ñ
    today = datetime.utcnow().replace(hour=0, minute=0, second=0, microsecond=0)
    today_result = await session.execute(
        select(func.count()).select_from(models.Ticket).where(models.Ticket.created_at >= today)
    )
    tickets_today = today_result.scalar_one() or 0
    
    return {
        "total_tickets": total_tickets,
        "tickets_today": tickets_today,
        "tickets_this_week": tickets_this_week,
        "status_distribution": status_stats
    }


async def get_response_time_stats(session: AsyncSession) -> dict:
    """ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºÑƒ Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ¸ Ğ¾Ñ‚Ğ²ĞµÑ‚Ğ°."""
    # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚Ñ‹Ğµ Ñ‚Ğ¸ĞºĞµÑ‚Ñ‹ Ñ Ğ¸Ñ… ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸ÑĞ¼Ğ¸
    query = select(models.Ticket).where(models.Ticket.status.in_([
        models.TicketStatus.CLOSED, models.TicketStatus.ARCHIVED
    ]))
    
    result = await session.execute(query)
    tickets = result.scalars().all()
    
    response_times = []
    for ticket in tickets:
        # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ Ğ´Ğ»Ñ ĞºĞ°Ğ¶Ğ´Ğ¾Ğ³Ğ¾ Ñ‚Ğ¸ĞºĞµÑ‚Ğ° Ğ¾Ñ‚Ğ´ĞµĞ»ÑŒĞ½Ğ¾
        messages_result = await session.execute(
            select(models.Message)
            .where(models.Message.ticket_id == ticket.id)
            .order_by(models.Message.created_at)
        )
        messages = messages_result.scalars().all()
        
        user_message = None
        bot_response = None
        
        for message in messages:
            if message.sender == "user" and user_message is None:
                user_message = message
            elif message.sender in ["bot", "operator"] and user_message and bot_response is None:
                bot_response = message
                break
        
        if user_message and bot_response:
            response_time = (bot_response.created_at - user_message.created_at).total_seconds() / 60  # Ğ² Ğ¼Ğ¸Ğ½ÑƒÑ‚Ğ°Ñ…
            response_times.append(response_time)
    
    if not response_times:
        return {"avg_response_time": 0, "min_response_time": 0, "max_response_time": 0}
    
    return {
        "avg_response_time": sum(response_times) / len(response_times),
        "min_response_time": min(response_times),
        "max_response_time": max(response_times)
    }


async def get_daily_tickets_stats(session: AsyncSession, days: int = 30) -> list[dict]:
    """ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºÑƒ Ñ‚Ğ¸ĞºĞµÑ‚Ğ¾Ğ² Ğ¿Ğ¾ Ğ´Ğ½ÑĞ¼ Ğ·Ğ° Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½Ğ¸Ğµ N Ğ´Ğ½ĞµĞ¹."""
    from datetime import datetime, timedelta
    
    end_date = datetime.utcnow().replace(hour=23, minute=59, second=59, microsecond=999999)
    start_date = end_date - timedelta(days=days-1)
    start_date = start_date.replace(hour=0, minute=0, second=0, microsecond=0)
    
    daily_stats = []
    current_date = start_date
    
    while current_date <= end_date:
        next_date = current_date + timedelta(days=1)
        
        result = await session.execute(
            select(func.count()).select_from(models.Ticket).where(
                and_(
                    models.Ticket.created_at >= current_date,
                    models.Ticket.created_at < next_date
                )
            )
        )
        count = result.scalar_one() or 0
        
        daily_stats.append({
            "date": current_date.strftime("%Y-%m-%d"),
            "tickets_count": count
        })
        
        current_date = next_date
    
    return daily_stats
 
 
 
 a s y n c   d e f   g e t _ a v e r a g e _ r e s p o n s e _ t i m e ( s e s s i o n :   A s y n c S e s s i o n )   - >   O p t i o n a l [ f l o a t ] : 
 
         " " " 
 
          _ U ï¿½ !S!!  Q! !
  !! ï¿½  ï¿½  ï¿½  ï¿½    ! ï¿½  X!   U!  T ï¿½  Q T ï¿½   (     X Q !S!  ï¿½ !& )   -    U!   ! U ï¿½  ï¿½ ï¿½   Q!   ï¿½  ï¿½ !  T Q   ï¿½ U   W ï¿½ !  U V U   U!   ï¿½ !  ï¿½    U W ï¿½ ! ï¿½ !  U! ï¿½ . 
 
            U ï¿½  ! ï¿½ !0  ï¿½  ï¿½ !   N o n e    ï¿½ ! ï¿½  Q    ï¿½ !    ï¿½ ï¿½   !9 !& . 
 
         " " " 
 
         f r o m   s q l a l c h e m y   i m p o r t   f u n c 
 
         
 
         r e s u l t   =   a w a i t   s e s s i o n . e x e c u t e ( 
 
                 s e l e c t ( 
 
                         f u n c . a v g ( 
 
                                 f u n c . j u l i a n d a y ( m o d e l s . T i c k e t . f i r s t _ r e s p o n s e _ a t )   -   
 
                                 f u n c . j u l i a n d a y ( m o d e l s . T i c k e t . c r e a t e d _ a t ) 
 
                         )   *   2 4   *   6 0     #    Y U   ï¿½ !!  Q!!S ï¿½  X   ï¿½  Q      X Q !S! !9 
 
                 ) . w h e r e ( 
 
                         m o d e l s . T i c k e t . f i r s t _ r e s p o n s e _ a t . i s n o t ( N o n e ) 
 
                 ) 
 
         ) 
 
         
 
         a v g _ m i n u t e s   =   r e s u l t . s c a l a r _ o n e ( ) 
 
         r e t u r n   r o u n d ( a v g _ m i n u t e s ,   1 )   i f   a v g _ m i n u t e s   e l s e   N o n e 
 
 
 
 
 
 a s y n c   d e f   g e t _ a v e r a g e _ r e s o l u t i o n _ t i m e ( s e s s i o n :   A s y n c S e s s i o n )   - >   O p t i o n a l [ f l o a t ] : 
 
         " " " 
 
          _ U ï¿½ !S!!  Q! !
  !! ï¿½  ï¿½  ï¿½  ï¿½    ! ï¿½  X!   U ï¿½ ! ï¿½  ï¿½  U!  T Q   ï¿½  ï¿½ !  T Q  (     X Q !S!  ï¿½ !& )   -    U!   ! U ï¿½  ï¿½ ï¿½   Q!   ï¿½ U   ï¿½  ï¿½  T!!9 !  Q!. 
 
            U ï¿½  ! ï¿½ !0  ï¿½  ï¿½ !   N o n e    ï¿½ ! ï¿½  Q    ï¿½ !    ï¿½ ï¿½   !9 !& . 
 
         " " " 
 
         f r o m   s q l a l c h e m y   i m p o r t   f u n c 
 
         
 
         r e s u l t   =   a w a i t   s e s s i o n . e x e c u t e ( 
 
                 s e l e c t ( 
 
                         f u n c . a v g ( 
 
                                 f u n c . j u l i a n d a y ( m o d e l s . T i c k e t . c l o s e d _ a t )   -   
 
                                 f u n c . j u l i a n d a y ( m o d e l s . T i c k e t . c r e a t e d _ a t ) 
 
                         )   *   2 4   *   6 0     #    Y U   ï¿½ !!  Q!!S ï¿½  X   ï¿½  Q      X Q !S! !9 
 
                 ) . w h e r e ( 
 
                         m o d e l s . T i c k e t . c l o s e d _ a t . i s n o t ( N o n e ) 
 
                 ) 
 
         ) 
 
         
 
         a v g _ m i n u t e s   =   r e s u l t . s c a l a r _ o n e ( ) 
 
         r e t u r n   r o u n d ( a v g _ m i n u t e s ,   1 )   i f   a v g _ m i n u t e s   e l s e   N o n e 
 
 